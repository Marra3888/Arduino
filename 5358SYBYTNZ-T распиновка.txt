Итоговая таблица распиновки CNH10:
Пин	Назначение	Описание и подключение
1	GND	Земля
2	VCC	Питание +5 В
3	VCC	Питание +5 В
4	ZCS1 (CS1)	Выбор чипа 1, через U7A к ZCS1, подтяжка R89
5	LCD_WR1 (R/W)	Чтение/запись, через U23A к ZWR, подтяжка R94
6	VO	Контрастность, через потенциометр J7
7	VO	Контрастность, через потенциометр J7
8	ZDIR (D/I)	Data/Instruction, через U23C к ZDIR
9	ZD8 (DB0)	Данные 0, через U25 (74HC245)
10	ZD9 (DB1)	Данные 1, через U25
11	ZD10 (DB2)	Данные 2, через U25
12	ZD11 (DB3)	Данные 3, через U25
13	ZD12 (DB4)	Данные 4, через U25
14	ZD13 (DB5)	Данные 5, через U25
15	ZD14 (DB6)	Данные 6, через U25
16	ZD15 (DB7)	Данные 7, через U25
17	RESET (RST)	Сброс, через U3B к LCD_RST, подтяжка R129
18	LCD_CS2 (CS2)	Выбор чипа 2, через U3B к ZCS2, подтяжка R129
19	LED_ON	Подсветка, через Q1 и R116
20	VCC	Питание +5 В

Особенности:
Контроллер: Предположительно KS0108B (128x64 пикселей).
Библиотека: Используем U8g2, так как она поддерживает KS0108 и упрощает работу с дисплеем. Если вы хотите код без библиотеки, уточните, и я напишу низкоуровневую реализацию.
Платформа: Arduino (например, Arduino Uno).
Отсутствие E (Enable): В распиновке нет сигнала E, который обычно требуется для KS0108. Предполагаю, что он реализован внутри модуля дисплея или не требуется в данной конфигурации.
Код на C++ с использованием U8g2:

Копировать
#include <U8g2lib.h>
#include <SPI.h>

// Определение пинов для Arduino
#define LCD_CS1  2   // Пин 4 - ZCS1 (Chip Select 1)
#define LCD_CS2  3   // Пин 18 - LCD_CS2 (Chip Select 2)
#define LCD_RST  4   // Пин 17 - RESET
#define LCD_DI   5   // Пин 8 - ZDIR (Data/Instruction)
#define LCD_RW   6   // Пин 5 - LCD_WR1 (Read/Write)
#define LCD_EN   7   // Пин Enable (нет в распиновке, но требуется для U8g2, используем любой свободный пин)
#define LED_ON   8   // Пин 19 - Подсветка

// Инициализация дисплея (KS0108, 128x64)
U8G2_KS0108_128X64_1 u8g2(U8G2_R0, 
                          9, 10, 11, 12, 13, 14, 15, 16, // DB0–DB7 (пины 9–16)
                          LCD_EN, LCD_RW, LCD_DI, 
                          LCD_CS1, LCD_CS2, LCD_RST);

void setup() {
  // Настройка пина подсветки
  pinMode(LED_ON, OUTPUT);
  digitalWrite(LED_ON, HIGH); // Включаем подсветку

  // Инициализация дисплея
  u8g2.begin();
}

void loop() {
  // Начало отрисовки
  u8g2.firstPage();
  do {
    // Установка шрифта
    u8g2.setFont(u8g2_font_ncenB08_tr);
    
    // Вывод текста
    u8g2.drawStr(0, 10, "Hello, World!");
    u8g2.drawStr(0, 20, "Disp: 5358SYBYTNZ-T");
    
    // Пример рисования линии
    u8g2.drawLine(0, 30, 127, 30);
    
    // Пример прямоугольника
    u8g2.drawFrame(10, 40, 50, 20);
  } while (u8g2.nextPage());
  
  delay(1000); // Задержка для обновления
}
Пояснения к коду:
Библиотека U8g2:
Поддерживает KS0108 и упрощает работу с дисплеем.
Установите через Arduino IDE (Library Manager: "U8g2").
Позволяет легко выводить текст и графику.
Пины:
DB0–DB7: Пиды 9–16 подключены к пинам Arduino 9–16.
ZCS1 (CS1): Пин 4 → Arduino 2.
LCD_CS2 (CS2): Пин 18 → Arduino 3.
RESET: Пин 17 → Arduino 4.
ZDIR (D/I): Пин 8 → Arduino 5.
LCD_WR1 (R/W): Пин 5 → Arduino 6.
LED_ON: Пин 19 → Arduino 8.
LCD_EN: В распиновке отсутствует сигнал E (Enable), но U8g2 требует его. Я добавил пин 7 (Arduino 7), но он не подключён к дисплею. Если сигнал E есть в модуле или схема его не требует, это не повлияет на работу.
Функционал:
В setup(): Включается подсветка (пин LED_ON) и инициализируется дисплей.
В loop(): Выводится текст ("Hello, World!" и название дисплея), рисуется линия и рамка прямоугольника.
firstPage()/nextPage(): Механизм постраничной отрисовки для KS0108.
Контрастность (VO):
Пиды 6 и 7 (VO) подключены к потенциометру J7 (10 кОм) между VCC и GND. Код не управляет контрастностью, её нужно настроить вручную, вращая потенциометр.
Подсветка:
Управляется через пин LED_ON (пин 19). В коде подсветка включается (HIGH).
Подключение к Arduino:
Пины 9–16 (DB0–DB7): Подключите к цифровым пинам Arduino 9–16.
Пин 4 (ZCS1): К пину Arduino 2.
Пин 18 (LCD_CS2): К пину Arduino 3.
Пин 17 (RESET): К пину Arduino 4.
Пин 8 (ZDIR, D/I): К пину Arduino 5.
Пин 5 (LCD_WR1, R/W): К пину Arduino 6.
Пин 19 (LED_ON): К пину Arduino 8.
Пины 1 (GND): К GND Arduino.
Пины 2, 3, 20 (VCC): К +5 В Arduino.
Пины 6, 7 (VO): К среднему выводу потенциометра (10–20 кОм), крайние выводы которого подключены к VCC и GND.
Если без библиотеки:
Если вы хотите низкоуровневый код без U8g2 (прямое управление KS0108), я могу написать его. Вот краткий пример инициализации и вывода пикселя:

#define LCD_CS1  2   // Пин 4
#define LCD_CS2  3   // Пин 18
#define LCD_RST  4   // Пин 17
#define LCD_DI   5   // Пин 8
#define LCD_RW   6   // Пин 5
#define LED_ON   8   // Пин 19

// DB0–DB7 на пинах 9–16
void setup() {
  // Настройка пинов
  for (int i = 9; i <= 16; i++) {
    pinMode(i, OUTPUT);
  }
  pinMode(LCD_CS1, OUTPUT);
  pinMode(LCD_CS2, OUTPUT);
  pinMode(LCD_RST, OUTPUT);
  pinMode(LCD_DI, OUTPUT);
  pinMode(LCD_RW, OUTPUT);
  pinMode(LED_ON, OUTPUT);

  // Включение подсветки
  digitalWrite(LED_ON, HIGH);

  // Сброс дисплея
  digitalWrite(LCD_RST, LOW);
  delay(10);
  digitalWrite(LCD_RST, HIGH);
  delay(10);

  // Инициализация дисплея
  writeCommand(0x3F, 0); // Включение дисплея (CS1)
  writeCommand(0x3F, 1); // Включение дисплея (CS2)
  writeCommand(0xC0, 0); // Установка начальной строки (CS1)
  writeCommand(0xC0, 1); // Установка начальной строки (CS2)
}

void writeCommand(byte cmd, bool cs) {
  digitalWrite(LCD_CS1, cs == 0 ? LOW : HIGH);
  digitalWrite(LCD_CS2, cs == 1 ? LOW : HIGH);
  digitalWrite(LCD_DI, LOW);  // Команда
  digitalWrite(LCD_RW, LOW);  // Запись
  for (int i = 0; i < 8; i++) {
    digitalWrite(9 + i, (cmd >> i) & 0x01);
  }
  delayMicroseconds(10); // Задержка для стабильности
}

void loop() {
  // Пример: зажечь пиксель (нужно добавить логику адресации)
}
Примечания:
Enable (E): В распиновке отсутствует сигнал E, который обычно есть в KS0108. Если он требуется, уточните его пин, и я скорректирую код.
Контрастность: Настройте потенциометр вручную.
Пины: Убедитесь, что пины Arduino соответствуют подключению.



// Определение пинов (на основе вашей распиновки)
#define LCD_CS1  2   // Пин 4 - ZCS1 (Chip Select 1)
#define LCD_CS2  3   // Пин 18 - LCD_CS2 (Chip Select 2)
#define LCD_RST  4   // Пин 17 - RESET
#define LCD_DI   5   // Пин 8 - ZDIR (Data/Instruction)
#define LCD_RW   6   // Пин 5 - LCD_WR1 (Read/Write)
#define LED_ON   8   // Пин 19 - Подсветка

// Простой шрифт 5x7 (для символов A-Z, 0-9, пробел)
const byte font5x7[37][5] PROGMEM = {
  {0x7E, 0x09, 0x09, 0x09, 0x7E}, // A
  {0x7F, 0x49, 0x49, 0x49, 0x36}, // B
  {0x3E, 0x41, 0x41, 0x41, 0x22}, // C
  {0x7F, 0x41, 0x41, 0x41, 0x3E}, // D
  {0x7F, 0x49, 0x49, 0x49, 0x41}, // E
  {0x7F, 0x09, 0x09, 0x09, 0x01}, // F
  {0x3E, 0x41, 0x41, 0x49, 0x2A}, // G
  {0x7F, 0x08, 0x08, 0x08, 0x7F}, // H
  {0x00, 0x41, 0x7F, 0x41, 0x00}, // I
  {0x20, 0x40, 0x41, 0x3F, 0x01}, // J
  {0x7F, 0x08, 0x14, 0x22, 0x41}, // K
  {0x7F, 0x40, 0x40, 0x40, 0x40}, // L
  {0x7F, 0x02, 0x04, 0x02, 0x7F}, // M
  {0x7F, 0x04, 0x08, 0x10, 0x7F}, // N
  {0x3E, 0x41, 0x41, 0x41, 0x3E}, // O
  {0x7F, 0x09, 0x09, 0x09, 0x06}, // P
  {0x3E, 0x41, 0x51, 0x21, 0x5E}, // Q
  {0x7F, 0x09, 0x19, 0x29, 0x46}, // R
  {0x46, 0x49, 0x49, 0x49, 0x31}, // S
  {0x01, 0x01, 0x7F, 0x01, 0x01}, // T
  {0x3F, 0x40, 0x40, 0x40, 0x3F}, // U
  {0x1F, 0x20, 0x40, 0x20, 0x1F}, // V
  {0x3F, 0x40, 0x30, 0x40, 0x3F}, // W
  {0x63, 0x14, 0x08, 0x14, 0x63}, // X
  {0x07, 0x08, 0x70, 0x08, 0x07}, // Y
  {0x61, 0x51, 0x49, 0x45, 0x43}, // Z
  {0x3E, 0x51, 0x49, 0x45, 0x3E}, // 0
  {0x00, 0x42, 0x7F, 0x40, 0x00}, // 1
  {0x42, 0x61, 0x51, 0x49, 0x46}, // 2
  {0x21, 0x41, 0x45, 0x4B, 0x31}, // 3
  {0x18, 0x14, 0x12, 0x7F, 0x10}, // 4
  {0x27, 0x45, 0x45, 0x45, 0x39}, // 5
  {0x3C, 0x4A, 0x49, 0x49, 0x30}, // 6
  {0x01, 0x71, 0x09, 0x05, 0x03}, // 7
  {0x36, 0x49, 0x49, 0x49, 0x36}, // 8
  {0x06, 0x49, 0x49, 0x29, 0x1E}, // 9
  {0x00, 0x00, 0x00, 0x00, 0x00}  // Пробел
};

// Функция записи команды
void writeCommand(byte cmd, bool cs) {
  digitalWrite(LCD_CS1, cs == 0 ? LOW : HIGH);
  digitalWrite(LCD_CS2, cs == 1 ? LOW : HIGH);
  digitalWrite(LCD_DI, LOW);  // Команда
  digitalWrite(LCD_RW, LOW);  // Запись
  for (int i = 0; i < 8; i++) {
    digitalWrite(9 + i, (cmd >> i) & 0x01);
  }
  delayMicroseconds(10); // Задержка для стабильности
}

// Функция записи данных
void writeData(byte data, bool cs) {
  digitalWrite(LCD_CS1, cs == 0 ? LOW : HIGH);
  digitalWrite(LCD_CS2, cs == 1 ? LOW : HIGH);
  digitalWrite(LCD_DI, HIGH); // Данные
  digitalWrite(LCD_RW, LOW);  // Запись
  for (int i = 0; i < 8; i++) {
    digitalWrite(9 + i, (data >> i) & 0x01);
  }
  delayMicroseconds(10); // Задержка для стабильности
}

// Установка адреса страницы (Y) и столбца (X)
void setAddress(byte page, byte column, bool cs) {
  writeCommand(0xB8 | (page & 0x07), cs); // Установка страницы (0-7)
  writeCommand(0x40 | (column & 0x3F), cs); // Установка столбца (0-63)
}

// Очистка экрана
void clearScreen() {
  for (byte cs = 0; cs < 2; cs++) { // Для CS1 и CS2
    for (byte page = 0; page < 8; page++) { // 8 страниц (по 8 пикселей по Y)
      setAddress(page, 0, cs);
      for (byte col = 0; col < 64; col++) { // 64 столбца
        writeData(0x00, cs); // Заполняем нули
      }
    }
  }
}

// Вывод символа на экран (x - столбец, y - страница)
void drawChar(char c, byte x, byte y) {
  int charIndex;
  if (c >= 'A' && c <= 'Z') charIndex = c - 'A';
  else if (c >= '0' && c <= '9') charIndex = (c - '0') + 26;
  else charIndex = 36; // Пробел

  byte cs = (x < 64) ? 0 : 1; // Выбор CS1 (0-63) или CS2 (64-127)
  byte col = x % 64; // Столбец внутри половины дисплея

  setAddress(y, col, cs);
  for (byte i = 0; i < 5; i++) { // 5 столбцов на символ
    byte data = pgm_read_byte(&font5x7[charIndex][i]);
    writeData(data, cs);
  }
  writeData(0x00, cs); // Пробел между символами
}

// Вывод строки текста
void drawString(const char* str, byte x, byte y) {
  byte posX = x;
  while (*str) {
    drawChar(*str, posX, y);
    posX += 6; // 5 пикселей на символ + 1 пробел
    str++;
  }
}

void setup() {
  // Настройка пинов
  for (int i = 9; i <= 16; i++) {
    pinMode(i, OUTPUT);
  }
  pinMode(LCD_CS1, OUTPUT);
  pinMode(LCD_CS2, OUTPUT);
  pinMode(LCD_RST, OUTPUT);
  pinMode(LCD_DI, OUTPUT);
  pinMode(LCD_RW, OUTPUT);
  pinMode(LED_ON, OUTPUT);

  // Включение подсветки
  digitalWrite(LED_ON, HIGH);

  // Сброс дисплея
  digitalWrite(LCD_RST, LOW);
  delay(10);
  digitalWrite(LCD_RST, HIGH);
  delay(10);

  // Инициализация дисплея
  writeCommand(0x3F, 0); // Включение дисплея (CS1)
  writeCommand(0x3F, 1); // Включение дисплея (CS2)
  writeCommand(0xC0, 0); // Установка начальной строки (CS1)
  writeCommand(0xC0, 1); // Установка начальной строки (CS2)

  // Очистка экрана
  clearScreen();
}

void loop() {
  // Вывод текста на экран
  drawString("HELLO WORLD", 0, 0); // Первая строка (страница 0)
  drawString("5358SYBYTNZ T", 0, 1); // Вторая строка (страница 1)

  delay(5000); // Пауза 5 секунд

  // Очистка экрана и вывод другого текста
  clearScreen();
  drawString("GROK 3 XAI", 0, 0);
  drawString("APRIL 2025", 0, 1);

  delay(5000); // Пауза 5 секунд
}

Пояснения к коду:
Шрифт:
Определён массив font5x7 с символами A-Z, 0-9 и пробелом.
Каждый символ — 5x7 пикселей (5 байт, по 7 бит для строк символа).
Хранится в PROGMEM для экономии оперативной памяти.
Функции:
writeCommand: Записывает команду (например, включение дисплея).
writeData: Записывает данные (пиксели).
setAddress: Устанавливает страницу (Y) и столбец (X) для записи.
clearScreen: Очищает экран, заполняя все пиксели нулями.
drawChar: Рисует один символ в заданной позиции (x, y).
drawString: Рисует строку текста, вызывая drawChar для каждого символа.
Координаты:
Дисплей 128x64 разделён на две половины (CS1: 0–63, CS2: 64–127 по X).
По Y: 8 страниц (0–7), каждая страница — 8 пикселей по вертикали.
drawChar и drawString учитывают выбор CS1/CS2 в зависимости от координаты X.
Текст:
В loop() выводятся две строки текста: "HELLO WORLD" и "5358SYBYTNZ T".
Через 5 секунд экран очищается, и выводится новый текст: "GROK 3 XAI" и "APRIL 2025".
Ограничения:
Шрифт поддерживает только A-Z, 0-9 и пробел. Для других символов нужно расширить массив font5x7.
Код не использует сигнал E (Enable), так как он отсутствует в вашей распиновке. Если он нужен, уточните пин.
Подключение к Arduino:
DB0–DB7 (пины 9–16): К пинам Arduino 9–16.
ZCS1 (пин 4): К Arduino 2.
LCD_CS2 (пин 18): К Arduino 3.
RESET (пин 17): К Arduino 4.
ZDIR (D/I, пин 8): К Arduino 5.
LCD_WR1 (R/W, пин 5): К Arduino 6.
LED_ON (пин 19): К Arduino 8.
GND (пин 1): К GND Arduino.
VCC (пины 2, 3, 20): К +5 В Arduino.
VO (пины 6, 7): К среднему выводу потенциометра (10–20 кОм), крайние выводы которого подключены к VCC и GND.
Примечания:
Контрастность: Настройте потенциометр (пины 6, 7) для оптимальной видимости.
Подсветка: Включается в setup() через пин LED_ON.
Производительность: Задержки delayMicroseconds(10) могут быть скорректированы для вашей платы.
Расширение шрифта: Для поддержки других символов добавьте их в массив font5x7.


Контроллер UC1601 (UltraChip UC1601) — это драйвер для монохромных STN ЖК-дисплеев, часто используемый в компактных устройствах, таких как мобильные телефоны, MP3-плееры и калькуляторы. Он поддерживает дисплеи с разрешением до 65x132 пикселей (в некоторых версиях, например, UC1601S) и предназначен для работы с низким энергопотреблением. UC1601 не имеет сигналов CS1 и CS2, в отличие от контроллеров типа KS0108B, так как он управляет дисплеем целиком через единый интерфейс (без разделения на половины экрана). Давайте разберём его характеристики и распиновку на основе стандартного модуля.

Основные характеристики UC1601:
Разрешение: До 65x132 пикселей (зависит от версии, например, UC1601S).
Тип дисплея: Монохромный STN/FSTN.
Интерфейсы: Поддерживает 6800/8080 параллельный интерфейс, I²C или SPI (3-проводной или 4-проводной).
Режимы работы: Может работать в графическом или текстовом режиме.
Особенности:
Встроенная RAM для хранения данных дисплея.
256-уровневая регулировка яркости/контрастности.
Встроенный генератор напряжения и регулятор контрастности, что снижает количество внешних компонентов.
Напряжение питания:
VDD: 2.7–3.3 В (логика).
VLCD: 5–12 В (для дисплея, зависит от конфигурации).
Энергопотребление: Очень низкое, около 60 мА (при VLCD = 5 В) [Web ID: 2].
Распиновка UC1601:
UC1601 обычно поставляется в виде микросхемы или встроен в модуль дисплея (COG — Chip on Glass). Для примера возьмём типичный модуль с UC1601, например, 26-контактный дисплей 128x64 (как в [Web ID: 16]). Распиновка может варьироваться в зависимости от модуля, но я опишу стандартный вариант для параллельного интерфейса или SPI.

Пример распиновки для 26-контактного модуля (128x64, UC1601):
VSS (GND) — Земля (0 В).
VDD — Питание логики (2.7–3.3 В, обычно 3 В).
VLCD — Питание для дисплея (5–12 В, обычно 5 В для STN).
D0 (SDA) — Линия данных для SPI/I²C или младший бит данных для параллельного интерфейса.
D1 — Линия данных (для параллельного интерфейса) или не используется в SPI.
D2 — Линия данных (для параллельного интерфейса) или не используется в SPI.
D3 — Линия данных (для параллельного интерфейса) или не используется в SPI.
D4 — Линия данных (для параллельного интерфейса) или не используется в SPI.
D5 — Линия данных (для параллельного интерфейса) или не используется в SPI.
D6 — Линия данных (для параллельного интерфейса) или не используется в SPI.
D7 — Линия данных (для параллельного интерфейса) или не используется в SPI.
CD (A0) — Выбор данных/команды (Data/Command, аналог D/I: 0 — команда, 1 — данные).
WR0 (SCL) — Сигнал записи (Write) для параллельного интерфейса или тактовый сигнал для SPI/I²C.
WR1 — Второй сигнал записи (для 6800-интерфейса) или не используется в SPI.
RD — Сигнал чтения (Read) для параллельного интерфейса (в SPI обычно подтянут к GND).
CS0 — Выбор чипа (Chip Select, активный уровень низкий). UC1601 использует единый CS, а не CS1/CS2.
RST — Сброс (Reset, активный уровень низкий).
PS0 — Выбор интерфейса (например, 0 — SPI, 1 — параллельный).
PS1 — Выбор подтипа интерфейса (например, 0/1 для выбора 3/4-проводного SPI).
VB0+ — Выход положительного напряжения для смещения дисплея (обычно с конденсатором 1 мкФ).
VB0- — Выход отрицательного напряжения для смещения (с конденсатором 1 мкФ).
VB1+ — Ещё один выход напряжения смещения (с конденсатором 1 мкФ).
VB1- — Ещё один выход напряжения смещения (с конденсатором 1 мкФ).
LED_A — Анод светодиодной подсветки (если есть).
LED_K — Катод светодиодной подсветки (если есть).
NC — Не подключён (или может быть дополнительный GND).
Примечания к распиновке:
Отсутствие CS1/CS2: UC1601 управляет всем дисплеем через единый сигнал CS0, в отличие от KS0108B, который разделяет экран на две части (CS1 и CS2). Это делает UC1601 более простым в управлении для небольших дисплеев [Web ID: 5].
Интерфейс: В SPI-режиме используются только D0 (SDA) и WR0 (SCL), остальные линии данных (D1–D7) подтягиваются к GND или не используются.
Смещение (VB0±, VB1±): Эти пины подключены к конденсаторам (обычно 1 мкФ) для стабилизации напряжения смещения дисплея [Web ID: 2].
Контрастность: Регулируется программно через команду (например, 0x81, затем значение контрастности от 0 до 255) [Web ID: 15].
Пример кода для UC1601 (на основе SPI):
Вот адаптированный код для Arduino, использующий SPI-интерфейс для вывода текста на дисплей 128x64 с UC1601. Код основан на вашей предыдущей просьбе, но адаптирован под UC1601.

// Определение пинов для Arduino (пример для SPI)
#define LCD_CS   2   // Пин 16 - CS0
#define LCD_RST  3   // Пин 17 - RESET
#define LCD_DI   4   // Пин 12 - CD (A0, Data/Command)
#define LCD_SCL  5   // Пин 13 - WR0 (SCL, тактовый сигнал SPI)
#define LCD_SDA  6   // Пин 4 - D0 (SDA, данные SPI)
#define LED_ON   7   // Пин 24/25 - Подсветка (анод/катод)

// Простой шрифт 5x7 (A-Z, 0-9, пробел)
const byte font5x7[37][5] PROGMEM = {
  {0x7E, 0x09, 0x09, 0x09, 0x7E}, // A
  {0x7F, 0x49, 0x49, 0x49, 0x36}, // B
  {0x3E, 0x41, 0x41, 0x41, 0x22}, // C
  // ... остальные символы (как в предыдущем коде)
  {0x00, 0x00, 0x00, 0x00, 0x00}  // Пробел
};

// Функция записи команды
void writeCommand(byte cmd) {
  digitalWrite(LCD_CS, LOW);
  digitalWrite(LCD_DI, LOW);  // Команда
  for (int i = 7; i >= 0; i--) {
    digitalWrite(LCD_SCL, LOW);
    digitalWrite(LCD_SDA, (cmd >> i) & 0x01);
    digitalWrite(LCD_SCL, HIGH);
  }
  digitalWrite(LCD_CS, HIGH);
}

// Функция записи данных
void writeData(byte data) {
  digitalWrite(LCD_CS, LOW);
  digitalWrite(LCD_DI, HIGH); // Данные
  for (int i = 7; i >= 0; i--) {
    digitalWrite(LCD_SCL, LOW);
    digitalWrite(LCD_SDA, (data >> i) & 0x01);
    digitalWrite(LCD_SCL, HIGH);
  }
  digitalWrite(LCD_CS, HIGH);
}

// Установка адреса страницы (Y) и столбца (X)
void setAddress(byte page, byte column) {
  writeCommand(0xB0 | (page & 0x0F)); // Установка страницы (0-7)
  writeCommand(0x00 | (column & 0x0F)); // Младший байт X
  writeCommand(0x10 | ((column >> 4) & 0x0F)); // Старший байт X
}

// Очистка экрана
void clearScreen() {
  for (byte page = 0; page < 8; page++) {
    setAddress(page, 0);
    for (byte col = 0; col < 128; col++) {
      writeData(0x00); // Заполняем нули
    }
  }
}

// Вывод символа на экран
void drawChar(char c, byte x, byte y) {
  int charIndex;
  if (c >= 'A' && c <= 'Z') charIndex = c - 'A';
  else if (c >= '0' && c <= '9') charIndex = (c - '0') + 26;
  else charIndex = 36; // Пробел

  setAddress(y, x);
  for (byte i = 0; i < 5; i++) {
    byte data = pgm_read_byte(&font5x7[charIndex][i]);
    writeData(data);
  }
  writeData(0x00); // Пробел между символами
}

// Вывод строки текста
void drawString(const char* str, byte x, byte y) {
  byte posX = x;
  while (*str) {
    drawChar(*str, posX, y);
    posX += 6; // 5 пикселей на символ + 1 пробел
    str++;
  }
}

void setup() {
  // Настройка пинов
  pinMode(LCD_CS, OUTPUT);
  pinMode(LCD_RST, OUTPUT);
  pinMode(LCD_DI, OUTPUT);
  pinMode(LCD_SCL, OUTPUT);
  pinMode(LCD_SDA, OUTPUT);
  pinMode(LED_ON, OUTPUT);

  // Включение подсветки
  digitalWrite(LED_ON, HIGH);

  // Сброс дисплея
  digitalWrite(LCD_RST, LOW);
  delay(10);
  digitalWrite(LCD_RST, HIGH);
  delay(10);

  // Инициализация дисплея
  writeCommand(0xA4); // Нормальный режим (не все пиксели включены)
  writeCommand(0xA6); // Нормальный дисплей (не инвертированный)
  writeCommand(0x81); // Установка контрастности
  writeCommand(0x40); // Значение контрастности (0–255, подстройте)
  writeCommand(0xAF); // Включение дисплея

  // Очистка экрана
  clearScreen();
}

void loop() {
  drawString("HELLO UC1601", 0, 0); // Первая строка
  drawString("128X64 DISPLAY", 0, 1); // Вторая строка

  delay(5000);

  clearScreen();
  drawString("GROK 3 XAI", 0, 0);
  drawString("APRIL 2025", 0, 1);

  delay(5000);
}

Подключение к Arduino:
D0 (SDA, пин 4): К пину Arduino 6.
WR0 (SCL, пин 13): К пину Arduino 5.
CD (A0, пин 12): К пину Arduino 4.
CS0 (пин 16): К пину Arduino 2.
RST (пин 17): К пину Arduino 3.
LED_A (пин 24): К пину Arduino 7 (анод подсветки).
LED_K (пин 25): К GND через резистор (например, 100 Ом).
VSS (пин 1): К GND Arduino.
VDD (пин 2): К 3.3 В Arduino.
VLCD (пин 3): К 5 В (или через схему для получения 5–12 В, если требуется).
Примечания:
Отсутствие CS1/CS2: UC1601 использует единый сигнал CS0, что упрощает управление по сравнению с KS0108B.
Контрастность: Настройте значение в команде 0x81 (например, 0x40) для оптимальной видимости.
Шрифт: Код использует шрифт 5x7, как в предыдущем примере. Для других символов нужно расширить массив font5x7.

