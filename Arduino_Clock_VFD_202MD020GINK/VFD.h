
// Функчия определения типа подключенного дисплея
// Умеет распознавать DN2029D, 202MD20GINK и его клонов BOE, 202MD25GINK.
// Если дисплей не подключен или не идентифицирован, включается встроенный
// на плате Arduino светодиод (D13) и подаётся звуковой сигнал раз в секунду.
// Цикл продолжается до момента обнаружения поддерживаемого дисплея.

#ifndef _VFD_h
#define _VFD_h

void Disp_detect() {

  byte i;
  bool disp_valid;

  //  Начальная инициализация дисплея
  PORTB |= 0b00001000; // поднимаем BLK
  PORTB |= 0b00001100; // + поднимаем LATCH
  PORTB &= ~0b00000100; // сбрасываем LATCH
  PORTB &= ~0b00001100; // + сбрасываем BLK

   // Прогоням все регистры нолями, очищаем от мусора
  for (i = 0; i < 150; i++) {
    PORTB |= 0b00000010; // поднимаем CLK
    PORTB &= ~0b00000010; // сбрасываем CLK
  }
  do  { // Выполняется до момента обнаружения поддерживаемого типа дисплея
    //  Начальная инициализация дисплея
    PORTB |= 0b00001000; // поднимаем BLK
    PORTB |= 0b00001100; // + поднимаем LATCH
    PORTB &= ~0b00000100; // сбрасываем LATCH
    PORTB &= ~0b00001100; // + сбрасываем BLK
    PORTB = 0b00001000; // поднимаем BLK

    //  Пишем единицу в регистр один раз
    PORTB |= 0b00000001; // поднимаем  SIN
    PORTB |= 0b00000011; //  + поднимаем CLK
    PORTB &= ~0b00000011; // сбрасываем CLK и SIN

    //  Прогоняем единицу через регистр, ждём её на выходе
    for (i = 0; i < 150; i++) {
      PORTB |= 0b00000010; // поднимаем CLK
      PORTB &= ~0b00000011; // сбрасываем CLK и SIN
      if (digitalRead(12) == 1) {  // Получаем результат
        Display_ID = i + 2;
      }
    }
    if ((Display_ID == 144) || (Display_ID == 128) || (Display_ID == 96)) { // Если обнаружен поддерживаемый дисплей
      disp_valid = 1;
    } else  { // Если дисплей не обнаружен или не поддерживается
      disp_valid = 0;
      PORTB |= 0b00100000;    // включаем светодиод
      digitalWrite(3, HIGH);   // Пищим зуммером
      delay(150);
      digitalWrite(3, LOW);
    //  beep();
      delay (1000);
    }
  } while (!disp_valid); // Повторяем цикл до момента обнаружения подходящего дисплея
}

// Функция выводит два символа в указанный столбец (сетку)
void output(byte grid) {    //   grid=0...19 - номер сетки

  byte s = 4, j = 0, i;
  byte line;
  /*
    // Массив значений управления яркостью дисплея, 15 уровней.
    // Использовать нецелесообразно, яркость в конце диапазона
    // регулирования почти не отличается от максимальной
    const byte dim_val[2][15] = { //dim steps = 15
      {0, 5, 10, 15, 20, 25, 30, 34, 35, 35, 35, 35, 35, 35, 35},
      {35, 35, 35, 35, 35, 35, 35, 0, 5, 10, 15, 20, 25, 30, 34},
    };
  */
  // Массив значений управления яркостью дисплея, 8 уровней.
  const byte dim_val[8] =  //dim steps = 8
  {0, 5, 10, 15, 20, 25, 30, 34};

  // Инициализация дисплея. Для всех одинаковая.
  PORTB = 0b00001000; // поднимаем BLK
  PORTB = 0b00001100; // + поднимаем LATCH
  PORTB = 0b00001000; // сбрасываем LATCH
  PORTB = 0b00000000; // + сбрасываем BLK

  // if (dot_flag) { //_____Мигаем встроенным светодиодом.
  //   PORTB |= 0b00100000;  // включаем светодиод
  // } else {
  //   PORTB &= ~0b00100000;  // выключаем светодиод
  // }

  // Функция вывода для дисплея Noritake Itron DN2029D. Поддерживает два варианта подключения.
  // Варианты подключения ( 0 или 1 ) задаются в основном коде значением #define DN2029D_wiring
//   if (Display_ID == 144) {
//     if (DN2029D_wiring == 1)  { //  Только для варианта подключения 1. Данные на SI. SO соединён с GSI. GSO выход.
//       for (i = 20; i > 0; i--) {  // 40 импульсов CLK  (сканирование сеток)
//         if (i - 1 == (grid)) {
//           PORTB |= 0b00000001; // поднимаем  SIN
//           PORTB |= 0b00000011; //  + поднимаем CLK
//           PORTB &= ~0b00000010; // сбрасываем CLK
//           PORTB |= 0b00000010; //  поднимаем CLK
//           PORTB &= ~0b00000011; // сбрасываем CLK и SIN
//         }  else {
//           PORTB |= 0b00000010; // поднимаем CLK
//           PORTB &= ~0b00000011; // сбрасываем CLK и SIN
//           PORTB |= 0b00000010; // поднимаем CLK
//           PORTB &= ~0b00000011; // сбрасываем CLK и SIN
//         }
//       }
//     }
//     for (line = 0; line < 2; line++) {  // Отрисовка символов. Общая функция для обоих вариантов подключения.
//       for (i = 0; i < 35; i++) { // 35 импульсов CLK   (рисуем символ)
//         if ((line == 0) && (dim) && (i >= dim_val[dim_level])) PORTB |= 0b00001000;  //Управление яркостью, 8 уровней
// //        if ((dim) && (i >= dim_val[line][dim_level])) PORTB |= 0b00001000;  //Управление яркостью, 15 уровней
//         if ((Symbol_buf[line][j + Scroll[line]] >> s) & 0x01) {
//           PORTB |= 0b00000001; // поднимаем  SIN
//           PORTB |= 0b00000011; // + поднимаем CLK
//           PORTB &= ~0b00000011; // сбрасываем CLK и SIN
//         } else {
//           PORTB |= 0b00000010; // поднимаем CLK
//           PORTB &= ~0b00000011; // сбрасываем CLK и SIN
//         }
//         if (s == 0) {
//           s = 4;
//           j++;
//         } else s--;
//         if (j == 7) j = 0;
//       }

//       for (i = 0; i < 5; i++) { // 5 импульсов CLK (подчеркивание, точка, запятая, 2 пустых)
//         PORTB |= 0b00000010; // поднимаем CLK
//         PORTB &= ~0b00000011; // сбрасываем CLK и SIN
//       }
//     }

//     for (i = 0; i < 16; i++)  { // 16 импульсов CLK (незадействованные выходы региста анодов)
//       PORTB |= 0b00000010; // поднимаем CLK
//       PORTB &= ~0b00000011; // сбрасываем CLK и SIN
//     }

//     if (DN2029D_wiring == 0)  { //  Только для варианта подключения 0. Данные на GSI. GSO соединён с SI. SO выход.
//       for (i = 0; i < 8; i++) { // 8 импульсов CLK  (незадействованные выходы региста сеток)
//         PORTB |= 0b00000010; // поднимаем CLK
//         PORTB &= ~0b00000011; // сбрасываем CLK и SIN
//       }
//       for (i = 20; i > 0; i--) {  // 40 импульсов CLK  (сканирование сеток)
//         if (i - 1 == (grid)) {
//           PORTB |= 0b00000001; // поднимаем  SIN
//           PORTB |= 0b00000011; //  + поднимаем CLK
//           PORTB &= ~0b00000010; // сбрасываем CLK
//           PORTB |= 0b00000010; //  поднимаем CLK
//           PORTB &= ~0b00000011; // сбрасываем CLK и SIN
//         }  else {
//           PORTB |= 0b00000010; // поднимаем CLK
//           PORTB &= ~0b00000011; // сбрасываем CLK и SIN
//           PORTB |= 0b00000010; // поднимаем CLK
//           PORTB &= ~0b00000011; // сбрасываем CLK и SIN
//         }
//       }
//     }
//   }
  
  // Универсальная Функция вывода для дисплеев
  // Futaba 202MD020GINK и 202MD025GINK
  // Должна подходить для дисплеев BOE CIG40-2003N и CIG40-2004N
  
  if ((Display_ID == 128) || (Display_ID == 96))  {    
    for (i = 0; i < 20; i++) {  // 20 импульсов CLK (сканирование сеток) общее для всех
      if (i == (grid)) {
        PORTB |= 0b00000001; // поднимаем  SIN
        PORTB |= 0b00000011; //  + поднимаем CLK
        PORTB &= ~0b00000011; // сбрасываем CLK и SIN
      }  else {
        PORTB |= 0b00000010; // поднимаем CLK
        PORTB &= ~0b00000011; // сбрасываем CLK и SIN
      }
    }

    if (Display_ID == 96) { // Только для Futaba 202MD025GINK
      PORTB |= 0b00000010; // поднимаем CLK        // 21 и 22-ой импульсы CLK(пустые).
      PORTB &= ~0b00000011; // сбрасываем CLK и SIN
      PORTB |= 0b00000010; // поднимаем CLK
      PORTB &= ~0b00000011; // сбрасываем CLK и SIN
    }

    for (line = 0; line < 2; line++) {  // Отрисовка символов. Общая для всех.
      for (i = 0; i < 35; i++) { // 35 импульсов CLK   (рисуем символ)
        if ((line == 0) && (dim) && (i >= dim_val[dim_level])) PORTB |= 0b00001000;  //Управление яркостью, 8 уровней
//          if ((dim) && (i >= dim_val[line][dim_level])) PORTB |= 0b00001000;  //Управление яркостью, 15 уровней
        if ((Symbol_buf[line][j + Scroll[line]] >> s) & 0x01) {
          PORTB |= 0b00000001; // поднимаем  SIN
          PORTB |= 0b00000011; // поднимаем CLK
          PORTB &= ~0b00000011; // сбрасываем CLK и SIN
        } else {
          PORTB |= 0b00000010; // поднимаем CLK
          PORTB &= ~0b00000011; // сбрасываем CLK и SIN
        }
        if (s == 0) {
          s = 4;
          j++;
        } else s--;
        if (j == 7) j = 0;
      }
      if (Display_ID == 128) { // Только для Futaba 202MD020GINK
        for (i = 0; i < 3; i++) { // 3 импульса CLK  (подчеркивание, точка, запятая)
          PORTB |= 0b00000010; // поднимаем CLK
          PORTB &= ~0b00000011; // сбрасываем CLK и SIN
        }
      }
    }
  }

}

#endif
